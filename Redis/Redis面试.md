-  Redis 和 Memcached 有什么区别？Redis 的线程模型是什么？为什么单线程的 Redis 比多线程的 Memcached 效率要高得多？

  Memcached的value只能是String；

- Redis 的过期策略都有哪些？手写一下 LRU 代码实现？

- 如何保证 Redis 高并发、高可用？Redis 的主从复制原理能介绍一下么？Redis 的哨兵原理能介绍一下么？

- Redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？

- Redis 集群模式的工作原理能说一下么？在集群模式下，Redis 的 key 是如何寻址的？分布式寻址都有哪些算法？了解一致性 hash 算法吗？如何动态增加和删除一个节点？

- 了解什么是 redis 的雪崩、穿透和击穿？Redis 崩溃之后会怎么样？系统该如何应对这种情况？如何处理 Redis 的穿透？

- 如何保证缓存与数据库的双写一致性？

- Redis 的并发竞争问题是什么？如何解决这个问题？了解 Redis 事务的 CAS 方案吗？

- 生产环境中的 Redis 是怎么部署的？





## 数据类型

**Redis 都有哪些数据类型？分别在哪些场景下使用比较合适？**



## 线程模型

**Redis 真的只有单线程吗？**

不是，Redis 单线程是指它对网络 IO 和数据读写的操作采用了一个线程；但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。



**基于多路复用的Redis高性能IO模型**

![](./pic/高性能IO模型.jpg)



**为什么单线程的 Redis 能那么快？**

1. 读写操作都在内存中
2. 高性能网络I/O模型
3. 避免了多线程并发控制带来的开销

## 持久化

AOF(Append only file) 和 RDB(Redis database)

**AOF写回策略**

- **Always**，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
- **Everysec**，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
- **No**，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。



**AOF 重写机制**

目的为了减小AOF日志的大小；重写过程是由后台子进程 bgrewriteaof 来完成的；

AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。

每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。最后，等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。



**AOF可能阻塞点**

- AOF重写时，父进程会调用fork，会阻塞，实例越大，阻塞越久。
- Copyonwrite机制在write时也会阻塞进行内存复制，如果开启了内存大页机制，阻塞时间将会更久。



**RDB给哪些数据做快照**

全量数据



**生成 RDB 文件两个命令**

- save: 在主线程中执行，会导致阻塞；

- bgsave: 创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。

  

**混合使用 AOF 日志和内存快照**

内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。



## 主从同步

**主从同步三种模式**

1. **全量复制**：主库生成RDB文件并发送给从库。从库接收之后，清空当前数据库，加载RDB文件。最后将replication buffer中记录的新命令发送给从库。

2. **基于长连接的命令传播**：主从之间一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库。

3. **增量复制**：当主从库断连后，主库会把断连期间收到的写操作命令，写入 repl_backlog_buffer 这个缓冲区。repl_backlog_buffer 是一个环形缓冲区，主库会记录自己写到的位置，从库则会记录自己已经读到的位置。

   调整 repl_backlog_size 这个参数来控制repl_backlog_buffer的大小。通过调大这个参数，可以减少从库在网络断连时全量复制的风险。



**主从复制为什么不用AOF日志？**

RDB文件更小因此传输效率更高；同时，数据恢复速度更快。



## 哨兵机制

**哨兵负责的三件事情**

1. **监控**

   周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。(主客观下线)

2. **选主**

   主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。

   条件：淘汰掉之前网络状况不好的节点，然后从库优先级、从库复制进度以及从库 ID 号为节点打分。

3. **通知**

   在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。

   ![](./pic/哨兵机制的三项任务与目标.jpg)



**哨兵集群**

哨兵间通信：基于Redis 提供的 pub/sub 机制，也就是发布 / 订阅机制。在主库上发布和订阅集群信息。



**哨兵是如何知道从库的 IP 地址和端口的呢？**

向主库发送 INFO 命令



**客户端事件通知**

哨兵与客户端通过Redis 提供的 pub/sub 机制通信，客户端可以订阅主库下线，主从切换事件。



**由哪个哨兵执行主从切换？哨兵选举**

1. 任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送 is-master-down-by-addr 命令。接着，其他实例会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。
2. 一个哨兵获得了仲裁所需的赞成票数(quorum)后，就可以标记主库为“客观下线”。
3. 这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为“Leader 选举”。因为最终执行主从切换的哨兵称为 Leader，投票过程就是确定 Leader。两个条件（半数以上赞成票以及大于配置的quorum值）
4. 成为Leader后，执行从库选主，然后通知客户端新主库信息。



## 性能

**有哪些阻塞操作？**

- 集合全量查询和聚合操作（优化点：使用scan分批读数据，在客户端聚合计算）
- bigkey删除(可异步)（优化点：4.0之前不支持异步删除，可使用scan分批删除）
- 清空数据库(可异步)
- AOF日志同步写(可异步)
- 加载RDB文件



**绑核操作**

- 对于多核CPU，使用taskset命令，将redis进程绑到同一个CPU核心上，避免频繁的线程切换。
- 对于NUMA架构，将redis与网络中断程序绑定到一个CPU Socket上的不同核，避免跨CPU Socket访问内存。

**绑核风险**

如果redis实例绑定到一个逻辑核上，子进程，后台线程会跟主进程抢cpu。

解决办法：

- 一个Redis实例对应绑一个物理核(两个逻辑核)
- 修改Redis fork部分源码，通过编程实现将子进程和后台线程绑定到与主进程不同的核上

