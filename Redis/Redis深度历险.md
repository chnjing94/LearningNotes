# 1. 基础和应用篇

## 1.1 Redis基础数据结构

Redis有5种基础数据结构，分别为：string（字符串）、list（列表）、hash（字典）、set（集合）和zset（有序集合）

### 1.1.1 String

- Redis字符串是动态字符串，可修改。

- 实现方式类似Java的ArrayList，通过预分配冗余空间来减少频繁的内存分配。
- 字符串长度小于1MB时，扩容是加倍现有空间。长度超过1MB时，每次扩容增加1MB的空间，字符串最大长度512MB。

### 1.1.2 List

- Redis列表相当于Java里面的LinkedList（实际底层是一种“quicklist”的快速列表），插入和删除时间复杂度为O(1)，定位查找时间复杂度O(n)。
- 元素之间使用双向指针连接，支持向前向后遍历。
- 常用来做异步队列，将任务序列化成字符串放入Redis的列表，别的线程从这个列表中轮询数据进行处理。
- ziplist是使用一块连续内存来实现链表，减少前后指针也就减少了内存使用。quicklist是将若干个ziplist双向连接起来。

### 1.1.3 Hash

- 相当于Java里的HashMap，数组+链表二维结构。
- key只能是字符串。
- 采用渐进式rehash策略，在rehash时，保留新旧两个hash，查询时会同时查两个hash，后续会定时将数据从旧的hash里移动到新的hash，迁移完成就会用新的hash代替旧的，然后回收其空间。

### 1.1.4 Set

- Redis集合相当于Java语言里面的HashSet。
- 内部实现是一个value为NULL的字典，所有的键值对是无序的，唯一的。

### 1.1.5 zset

- zset，有序列表，类似于Java的SortedSet和HashMap的结合体。
- 它是一个set，可以保证内部元素(value)的唯一性。
- 可以对set里的value，根据其score进行排序。
- 内部实现是由hash字典加上一种叫做“跳表”的数据结构。

### 1.1.6 容器型数据结构通用规则

1. create if not exists：如果容器不存在就先创建一个，再进行操作。
2. drop if no elements：如果容器里没有元素，就立即删除容器，释放内存。

### 1.1.7 过期时间

Redis的所有对象都可以设置过期时间，时间到了，就会自动删除该对象。过期是以对象为单位，比如一个hash结构，过期指的是整个hash对象，而不是里面的某个key。

# 5. 源码篇

## 5.5 zset与跳表

Redis的zset的内部实现是一个hash字典加一个跳表（skiplist）。hash字典用来存储value和score的对应关系。

### 5.5.1 基本结构

![](./pic/5-5跳表.jpg)

- 每一个元素（kv块）可能拥有不同的层高，例如元素3拥有L0，元素6拥有L0，L1。随着层数增加，拥有该层数的kv块数量会越来越少。
- 最底层kv块之间用双向链表串起来（上图中最底下一层的kv块之间的箭头应是双向的），按照从小到大的顺序排列。
- 同一层的kv块会用指针串起来，每一层元素的遍历都是从kv header出发。
- 共有64层，跳表会记录当前的最高层数maxLevel，很少有情况能达到64层，因为一般不会在跳表里放2的64次方个元素。

### 5.5.2 查找过程

- 从当前最高层开始，在每一层寻找那个最后一个比目标元素小的元素，直到在最后一层L0中找到期望的节点。
- 中间经过的一系列节点称为搜索路径，它是每一层最后一个比目标元素小的元素节点列表。有了这个搜索路径就可以确定新插入节点的位置。

### 5.5.3 随机层数

- 对于新插入的节点，需要确定它拥有的层数，Redis采用随机算法给它分配一个合理的层数。
- 首先，一个节点是100%拥有层数L0的，但是能够获得更大一层数的晋升几率只有25%。
- 低的晋升概率，导致了跳表的层数相对较低，在单个层上的遍历次数会稍多一点。

### 5.5.4 插入过程

- 首先要搜索出合适的插入点，将这个过程中的搜索路径找出来。
- 然后创建节点，并为这个节点随机分配一个层数，如果分配的层数高于当前跳表的最大高度，就需要更新当前最大高度。
- 将搜索路径上的节点和这个新节点通过向前向后指针串起来。

### 5.5.5 更新过程

- 调用zadd时，如果对应的value不存在，就是插入过程。
- 如果对应的value存在了，且score发生了变化，则先删除之前的元素，再插入拥有新score的元素。

### 5.5.6 删除过程

- 先找到要删除的节点，并把搜索路径找出来，对于该节点拥有的每一层的相关节点，重排一下前后指针。
- 注意可能会更新maxLevel。

### 5.5.7 元素排名

- Redis给forward指针都赋予了span属性，表示从前一个节点沿着forward指针跳到当前这个节点，中间会跳过多少个节点。Redis在插入，删除操作时都会更新span的值。
- 当要计算一个元素的排名时，只需要将搜索路径经过的所有节点的跨度span值进行叠加，就可以计算出元素的最终rank值。