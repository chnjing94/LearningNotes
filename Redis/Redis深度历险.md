# 1. 基础和应用篇

## 1.1 Redis基础数据结构

Redis有5种基础数据结构，分别为：string（字符串）、list（列表）、hash（字典）、set（集合）和zset（有序集合）

### 1.1.1 String

- Redis字符串是动态字符串，可修改。

- 实现方式类似Java的ArrayList，通过预分配冗余空间来减少频繁的内存分配。
- 字符串长度小于1MB时，扩容是加倍现有空间。长度超过1MB时，每次扩容增加1MB的空间，字符串最大长度512MB。

### 1.1.2 List

- Redis列表相当于Java里面的LinkedList（实际底层是一种“quicklist”的快速列表），插入和删除时间复杂度为O(1)，定位查找时间复杂度O(n)。
- 元素之间使用双向指针连接，支持向前向后遍历。
- 常用来做异步队列，将任务序列化成字符串放入Redis的列表，别的线程从这个列表中轮询数据进行处理。
- ziplist是使用一块连续内存来实现链表，减少前后指针也就减少了内存使用。quicklist是将若干个ziplist双向连接起来。

### 1.1.3 Hash

- 相当于Java里的HashMap，数组+链表二维结构。
- key只能是字符串。
- 采用渐进式rehash策略，在rehash时，保留新旧两个hash，查询时会同时查两个hash，后续会定时将数据从旧的hash里移动到新的hash，迁移完成就会用新的hash代替旧的，然后回收其空间。

### 1.1.4 Set

- Redis集合相当于Java语言里面的HashSet。
- 内部实现是一个value为NULL的字典，所有的键值对是无序的，唯一的。

### 1.1.5 zset

- zset，有序列表，类似于Java的SortedSet和HashMap的结合体。
- 它是一个set，可以保证内部元素(value)的唯一性。
- 可以对set里的value，根据其score进行排序。
- 内部实现是由hash字典加上一种叫做“跳表”的数据结构。

### 1.1.6 容器型数据结构通用规则

1. create if not exists：如果容器不存在就先创建一个，再进行操作。
2. drop if no elements：如果容器里没有元素，就立即删除容器，释放内存。

### 1.1.7 过期时间

Redis的所有对象都可以设置过期时间，时间到了，就会自动删除该对象。过期是以对象为单位，比如一个hash结构，过期指的是整个hash对象，而不是里面的某个key。

## 1.2 分布式锁

分布式锁是用来解决分布式应用之间的同步问题。使用Redis来实现分布式锁。

```
> setnx lock true
// 如果之前不存在lock变量，则返回1，相当于抢到了锁，否则返回0。
> del lock
// 用完之后删除lock，相当于释放锁。
```

### 1.2.1 死锁问题

如果加锁成功后，在释放锁之前出现异常，导致del指令不能被调用，这样锁永远都得不到释放。解决方法就是，在拿到锁之后，再给锁加一个过期时间，这样即使中途发生异常也可以保证锁到期后被释放。

```
> setnx lock true
> expire lock 5
···do something···
> del lock
```

但是仍然存在问题，就是拿到锁后，在设定锁过期时间之前发生异常，还是会造成死锁。

解决方法是把加锁和设置过期时间变成原子操作。

```
> set lock true ex5 nx
···do something···
> del lock 
```

### 1.2.2 超时问题

Redis分布式锁并不能解决超时问题，如果在加锁和释放锁之间的逻辑执行得太久，以至于超出了锁的超时限制，就会出现问题，导致临界区代码不能得到严格串行执行。为了避免这个问题，Redis分布式锁不要用于较长时间的任务。

### 1.2.3 可重入性

Redis要实现可重入性，可以对set方法进行包装，使用线程的Threadlocal变量存储当前持有锁的计数。

## 1.3 延时队列

Redis可以用来实现只有一个消费者组的消息队列，但是可靠性没有保障。使用list数据结构来作为一部消息队列使用，用rpush和lpush操作入队列，用lpop和rpop操作出队列。支持多个生产者和多个消费者并发进出消息，每个消费者拿到的消息都是不同的列表元素。

### 1.3.1 队列空了怎么办

队列空了，客户端会陷入pop的死循环，导致cpu消耗升高，通常使用sleep来解决这个问题，让线程睡一会儿再请求数据。

### 1.3.2 阻塞读

睡眠虽然可以解决空轮询问题，但是会导致消息延迟增大。因此更好的解决方案是阻塞读。使用命令`blpop/brpop`，阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来，消息的延迟几乎为0。

### 1.3.3 空闲连接自动断开

如果阻塞读长时间阻塞，会导致长时间占用资源，因此在阻塞了一段时间后，blpop/brpop会抛出异常。

### 1.3.4 延时队列的实现

延时队列可以通过redis的zset有序列表来实现。将消息序列化成一个字符串作为zset的value，将消息的到期处理时间作为score，然后用多个线程轮询zset获取到期的任务进行处理。使用redis.zrangebyscore("delay-queue, 0, time.time(), start=0, num=1")来获取一条满足到期时间的任务。然后使用redis.zrem来抢这条任务，因为多个线程都可以使用pop命令同时读到该消息，只有这一步成功了才算抢到了任务，可以执行该任务。

### 1.3.5 进一步优化

在上面的算法中，同一个任务可能会被多个进程取到之后再使用zrem进行争抢，那些没抢到的进程都白取了一次任务，这是浪费。因此可以考虑用lua scripting来优化，将zrangbyscore和zrem一同挪到服务端进行原子化操作，这样就不会出现这种浪费了。

## 1.4 位图

Redis中实现位图的方式是`setbit/getbit`命令。

```
> setbit s 1 1
> getbit s 1
> 1
> set w h
> getbit w 1
> 1
```

### 1.4.1 统计和查找

`bitcount key [start] [end]` 统计指定区间上1的个数

`bitpos key bit [start] [end]`返回变量key中第start个到end个字符中，第一个`bit`的位置。

### 1.4.2 bitfield

bitfield指令用于一次处理多个位的操作，最多同时处理64位。

 ```
> bitfield w get u4 0  // 从第一位开始取4个位，结果是无符号数（u）
> bitfield w get u4 0  // 从第一位开始取4个位，结果是有符号数（i）
> bitfield w set u8 8 97 // 从第9个位开始，将接下来的8个位用无符号数97替换
 ```

incrby用来对指定范围的位进行自增操作。对于溢出，Redis默认是折返，如果溢出，会将溢出的符号位丢掉。bitfield提供了溢出策略子命令overflow，可以选择失败(fail)以及饱和截断(sat)，饱和截断就是保持最大值 。

##1.5 HyperLogLog

HyperLogLog是一种set，提供不精确的去重技术方案，标准误差是0.81%，每个HyperLogLog占用12K的内存。

`pfadd`增加计数，`pfcount`获取计数，`pfmerge`将多个pf计数值累加到一起。

原理：

给定一系列的随机正数，记录下低位连续零位的最大长度K，通过K值可以估算随机数的数量N。HyperLogLog使用了16384个桶来计数，每个桶的maxbits使用6个bit进行计数，最大可以表示maxbits=64，因此占用12K内存。

1. 每到来一个随机数，先确定它放到某一个桶中，这里同时也实现了去重功能。
2. 求出它的低位连续零位，和当前这个桶的最大长度maxbits作比较。
3. 使用调和平均（倒数的平均）来计算平均数，这样能有效防止个别离群值对平均结果产生较大影响，最后根据桶的数量对估值进行放大。

## 1.6 布隆过滤器

### 1.6.1 是什么

布隆过滤器，从名字上看，是一种过滤器，就像茶叶过滤器一样，过滤掉的一定是茶叶，不可能是水，而留下来的可能有细小的茶叶，同样的布隆过滤器也有微小的误判率。

从数据结构上来说，它是一种高级set，提供set的add, contains函数，不同的是，首先，元素加进去了，不能再取出来了，add方法只是让布隆过滤器见一面这个元素，而不是真正存储起来，而contains函数告诉调用者，有没有见过这个元素，当他说没有，那就一定没有见过，当他说有，那就可能见过，可能没见过。第二，相比于set，布隆过滤器能节省90%空间。

### 1.6.2 能做什么

布隆过滤器提供不完全正确的去重检查功能，适用的场景有以下几种：

- 判断用户有没有读过谋篇新闻，将用户浏览过的所有新闻都加到布隆过滤器里面，当有一篇新的新闻来的时候，去过滤器里面查一查，如果说不存在，则用户一定没看过该新闻，就推送给用户，如果存在，那么大概率用户看过，就不推送给用户，即使错了，不会造成严重后果，大不了少看一条新闻。
- 垃圾邮件判定，用户每添加一个邮件地址黑名单，就加到布隆过滤器里，来了一封新邮件，问一下过滤器，这个地址是否在黑名单里，是就放到垃圾邮件分类里，如果没有见过，就放到正常邮箱。因此，可能会出现正常邮件被误判的情况，但是垃圾邮件一定被放到了垃圾邮件分类里。

### 1.6.3 基本用法

```
> df.add codehole user1
1
> df.exists codehole user1
1
> df.exists codehole user2
0
```

### 1.6.4 实现原理

布隆过滤器由一个位数组和若干个hash函数组成。每次通过add进来一个元素，使用每个hash函数求得多个hash值，并在hash值对应的数组位置上置为1。当调用exists来查找某个元素是否存在时，又使用每个hash函数求得多个hash值，检查每个hash值对应的数组位置上的值，如果都是1，则判定为存在，如果其中任何一个位置是0，则没有见过。当数组太小，而元素太多时，数组几乎都为1，那么出现误判的几率会大大上升，但是如果判定为不存在，那么这个元素一定不存在，不会出现误判。

### 1.6.5 注意事项

布隆过滤器允许用户设定两个初始化参数：

- initial_size：初始化大小，需要用户去估计里面会装多少个元素，设置得太大，浪费存储空间，需要的hash函数数量也更大，计算效率降低。设置得太小，影响准确率。
- error_rate，错误率，设置得越小，需要的空间越大，但是仍然远远小于set所需空间。



# 5. 源码篇

## 5.5 zset与跳表

Redis的zset的内部实现是一个hash字典加一个跳表（skiplist）。hash字典用来存储value和score的对应关系。

### 5.5.1 基本结构

![](./pic/5-5跳表.jpg)

- 每一个元素（kv块）可能拥有不同的层高，例如元素3拥有L0，元素6拥有L0，L1。随着层数增加，拥有该层数的kv块数量会越来越少。
- 最底层kv块之间用双向链表串起来（上图中最底下一层的kv块之间的箭头应是双向的），按照从小到大的顺序排列。
- 同一层的kv块会用指针串起来，每一层元素的遍历都是从kv header出发。
- 共有64层，跳表会记录当前的最高层数maxLevel，很少有情况能达到64层，因为一般不会在跳表里放2的64次方个元素。

### 5.5.2 查找过程

- 从当前最高层开始，在每一层寻找那个最后一个比目标元素小的元素，直到在最后一层L0中找到期望的节点。
- 中间经过的一系列节点称为搜索路径，它是每一层最后一个比目标元素小的元素节点列表。有了这个搜索路径就可以确定新插入节点的位置。

### 5.5.3 随机层数

- 对于新插入的节点，需要确定它拥有的层数，Redis采用随机算法给它分配一个合理的层数。
- 首先，一个节点是100%拥有层数L0的，但是能够获得更大一层数的晋升几率只有25%。
- 低的晋升概率，导致了跳表的层数相对较低，在单个层上的遍历次数会稍多一点。

### 5.5.4 插入过程

- 首先要搜索出合适的插入点，将这个过程中的搜索路径找出来。
- 然后创建节点，并为这个节点随机分配一个层数，如果分配的层数高于当前跳表的最大高度，就需要更新当前最大高度。
- 将搜索路径上的节点和这个新节点通过向前向后指针串起来。

### 5.5.5 更新过程

- 调用zadd时，如果对应的value不存在，就是插入过程。
- 如果对应的value存在了，且score发生了变化，则先删除之前的元素，再插入拥有新score的元素。

### 5.5.6 删除过程

- 先找到要删除的节点，并把搜索路径找出来，对于该节点拥有的每一层的相关节点，重排一下前后指针。
- 注意可能会更新maxLevel。

### 5.5.7 元素排名

- Redis给forward指针都赋予了span属性，表示从前一个节点沿着forward指针跳到当前这个节点，中间会跳过多少个节点。Redis在插入，删除操作时都会更新span的值。
- 当要计算一个元素的排名时，只需要将搜索路径经过的所有节点的跨度span值进行叠加，就可以计算出元素的最终rank值。