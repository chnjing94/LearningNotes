## 注册中心作用及设计分析

### 什么是注册中心？

用来实现微服务实例的自动注册与发现，是分布式系统中的核心基础服务

### 主要功能

- 服务注册

  服务提供方将自身路由信息，服务信息发布到注册中心，供消费方获取用于与提供方建立连接并发起调用。

  （路由信息： 节点IP，端口，服务信息：序列化协议，路由规则，节点权重）

- 服务发现

  服务消费方通过访问注册中心获取服务提供方节点路由信息。

  - 服务消费方启动后，从注册中心拉取服务提供方节点列表，建立连接，进行RPC调用。

  - 接受注册中心变更通知，重新获取数据，更新节点列表。
  - 服务消费方运行过程中定时拉取服务提供节点列表，更新本地数据。

- 健康检查

  确保已注册节点健康度，能够及时准确剔除失效节点，保证服务发现正确性

- 变更通知

  当服务提供方节点发生变更时，注册中心应该能够第一时间把变更事件或变更后的数据推送到服务订阅方。

- 服务治理相关

  服务扩/缩容，机器迁移，权重，灰度流量

### 设计实现

- 数据存储，需要存储的数据有

  - 每个服务节点的信息
  - 每种服务的集群信息
  - 每个节点订阅者的信息

- 超时处理

  当注册中心在超时时长内未收到服务节点的心跳，需要移除该节点信息。以下提供一种超时扫描方法

  ![](./pic/超时扫描.png)

  1. 服务节点向注册中心发起首次心跳时，带上参数expireTime(当前时间加上超时时长)，注册中心收到后，利用expireTime%BUCKET_SIZE算出，应该将这个节点放到哪个桶中。
  2. 服务节点在下一次心跳时，带上两个参数， oldexpireTime上一次心跳发送的expireTime，newexpireTime新的过期时间，注册中心根据oldexpireTime%BUCKET_SIZE找到对应的桶，将该节点从中移除（如果该节点不发心跳了，该节点就会一直留在那个桶中）。根据newexpireTime%BUCKET_SIZE找到新的桶，将该节点放到新的桶中。
  3. 注册中心每隔一秒访问一个桶，留在桶中的节点都是心跳超时的节点，不健康的节点，因此会被注册中心移除出节点列表。

  上述算法的优点是，不需要每次都遍历所有节点来判断是否过期。但是节点数少的时候，例如1000以内，每次都遍历所有节点其实也能接受。

- 实现思路

  1. 自带存储，保证数据一致性
  2. 逻辑+配套存储(Redis)

一个注册中心节点发生变更，怎么将变更通知到其他节点？Gossip协议

Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。

- 六度分离理论
- 周期性散播消息
- 随机选择N个节点散播
- 散播不重复(不是严格不重复)不回传

Gossip缺陷： 1. 消息延迟 2. 消息冗余，可能消息会重复发到同一个节点

### 注册中心选型对比

![](./pic/注册中心选型对比.png)

ZK是顺序一致性。

## Nacos分析

### 健康检查

对于临时节点（随时可能下线节点）采用心跳注册，临时实例使用心跳上报方式维持活性，5秒上报，15秒标记不健康，30秒剔除。对于持久化节点，采用tcp/http探测。

### 数据模型

- 数据存储

  ![](./pic/Nacos数据存储模型.png)

- 数据隔离

  四层数据隔离 1. 账号 2. 命名空间指定集群 3.分组 4.服务名标识服务   

- 数据一致性

  Raft CP一致性， Distro AP一致性

  Distro协议，每个节点维护注册在自己这里节点的心跳，通过广播的形式同步到其他节点。

## Zookeeper，Zab分析

Zab协议（Zookeeper Atomic Broadcast）

### 实现操作顺序性

如何实现？

- 将每个操作设定为一个提案，并赋予一个自增的ZXID
- Leader节点通过TPC协议保障提案有序地发送到Follwer节点？？？
- 按照ZXID，顺序提交提案，前一个提案未提交之前不能提交下一个

### 选主逻辑

节点角色：

server节点组成的一个集群，在集群中存在一个唯一的leader节点负责响应写入请求，其他节点只负责接收

转发Client请求。

Leader：响应写入请求，发起提案，超过半数Follower同意写入，写入成功；

Follower：响应查询，将写入请求发给Leader，参与选举和写入投票

ObServer：响应查询，将写入请求发给Leader，不参与投票，只接收写入结果

节点状态：

- LOOKING：选举状态，该状态下的节点认为当前集群中没有领导者，会发起领导者选举。
- FOLLOWING ：跟随者状态，意味着当前节点是跟随者。
- LEADING ：领导者状态，意味着当前节点是领导者。
- OBSERVING： 观察者状态，意味着当前节点是观察者。

获得过半投票数为新主，投票数据<proposedLeader, proposedEpoch, ZXID, node>

- proposedLeader，节点提议的，领导者的集群 ID，也就是在集群配置（比如 myid 配置文件）时指定的 ID。
- proposedEpoch，节点提议的，领导者的任期编号。
- proposedLastZxid，事务标识符，越大表示数据越新。
- node，投票的节点，比如节点 B。

比较策略：proposedEpoch大的胜出，proposedEpoch相同比较proposedLastZxid大的胜出，proposedLastZxid相同比较proposedLeader大的胜出。

选主流程：

![](./pic/Zab选主过程.jpg)

- 领导者选举的目标，是选举出大多数节点中数据最完整的节点，也就是大多数节点中事务标识符值最大的节点。
- 逻辑时钟（logicclock）（也就是选举的轮次），会影响选票的有效性，具体来说，逻辑时钟大的节点不会接收来自值小的节点的投票信息。
- 在领导者选举的实现中，事务标识符采用的是 dataTree.lastProcessedZxid 的值。需要你特别注意的是，在跟随者节点正常运行时，dataTree.lastProcessedZxid 表示的是已提交提案的事务标识符最大值，但当跟随者检测到异常，退出跟随者状态时（在 follower.shutdown() 函数中），跟随者会将所有未提交提案提交，并使用 lastProcessedZxid 表示节点上提案（包括刚提交的提案）的事务标识符的最大值，在接下来的领导者选举中，使用的也是该值，也就是说，ZAB 的领导者选举，选举出的是大多数节点中数据最完整的节点。

### 故障恢复

ZAB 定义了 4 种状态，来标识节点的运行状态。

- ELECTION（选举状态）：表明节点在进行领导者选举；
- DISCOVERY（成员发现状态）：表明节点在协商沟通领导者的合法性；
- SYNCHRONIZATION（数据同步状态）：表明集群的各节点以领导者的数据为准，修复数据副本的一致性；
- BROADCAST（广播状态）：表明集群各节点在正常处理写请求。

在节点完成了选举，退出ELECTION状态后，进入DISCOVERY状态

1. 成员发现

   成员发现是通过跟随者和领导者交互来完成的，目标是确保大多数节点对领导者的领导关系没有异议，也就是确立领导者的领导地位。

   ![](./pic/成员发现.jpg)

   FOLLOWINFO: 节点已接受的领导者任期编号最大值

   LEADINFO: 包含自己事务标识符最大值<新任期值，0>

   Follower接收到来自领导者的 LEADINFO 消息后，跟随者会基于领导者的任期编号，判断领导者是否合法，如果领导者不合法，跟随者发起新的选举，如果领导者合法，响应 ACKEPOCH（里面包含了自己最大的ZXID） 消息给领导者。

   ```java
   // 创建ACKEPOCH消息，包含已提交提案的事务标识符最大值
   QuorumPacket ackNewEpoch = new QuorumPacket(Leader.ACKEPOCH, lastLoggedZxid, epochBytes, null);
   // 响应ACKEPOCH消息给领导者
   writePacket(ackNewEpoch, true);
   ```

   

2. 数据同步

   ![](./pic/数据同步.jpg)

   1. 领导者根据跟随者的事务标识符值最大值，判断用哪种方式处理不一致数据，领导者向跟随者同步数据的三种方式（TRUNC、DIFF、SNAP）：

      TRUNC：通知跟随者丢弃超出的那部分提案。

      DIFF： 领导者会同步给跟随者缺失的已提交的提案。

      SNAP：跟随者缺失的提案比较多时，领导者同步快照数据给跟随者，并直接覆盖跟随者本地的数据。

   2. 领导者创建 NEWLEADER 消息，并缓存在发送队列中。

   3. 领导者调用 startSendingPackets() 函数，启动一个新线程，并将缓存的数据发送给跟随者。

   4. 跟随者调用 syncWithLeader() 函数，处理来自领导者的数据同步。

   5. 在 syncWithLeader() 函数，跟随者接收到来自领导者的 NEWLEADER 消息后，返回确认响应给领导者。

      ```java
      writePacket(new QuorumPacket(Leader.ACK, newLeaderZxid, null, null), true);
      ```

   6. 领导者等待来自大多数节点的 NEWLEADER 消息的响应。

   7. 当领导者接收到来自大多数节点的 NEWLEADER 消息的响应时，在 Leader.lead() 函数中，领导者设置 ZAB 状态为广播状态。并发送 UPTODATE 消息给所有跟随者，通知它们数据同步已完成了。

   8. 当跟随者接收到 UPTODATE 消息时，就知道自己修复完数据不一致了，可以处理写请求了，就设置 ZAB 状态为广播。

   

### 读写操作

Zookeeper的读请求可以在所有节点上，而写请求只能在主节点上，因此写请求的性能约等于单机。

写操作过程：

![](./pic/ZK写操作.jpg)

## Raft算法

Raft中有三种成员身份

- 跟随者：就相当于普通群众，默默地接收和处理来自领导者的消息，当等待领导者心跳信息超时的时候，就主动站出来，推荐自己当候选人。
- 候选人：候选人将向其他节点发送请求投票（RequestVote）RPC 消息，通知其他节点来投票，如果赢得了大多数选票，就晋升当领导者。
- 领导者：蛮不讲理的霸道总裁，一切以我为准，平常的主要工作内容就是 3 部分，处理写请求、管理日志复制和不断地发送心跳信息，通知其他节点“我是领导者，我还活着，你们现在不要发起新的选举，找个新领导者来替代我。”

### 选主过程



