# 2. 日志系统

##一条SQL更新语句是如何执行的？

```sql
mysql> create table T(ID int primary key, c int);
mysql> update T set c=c+1 where ID=2;
```

![](./pic/2-update执行过程.png)

## 两阶段提交

更新完内存中的数据之后，写入redo log，并处于prepare阶段，但并事务没有提交，即使此时

刷盘，之后被读出来依然是未提交数据。等到binlog写入完成，将事务正式提交，处于commit状态。

两阶段提交的目的是为了保证数据库的状态和用它的日志恢复出来的库的状态一致，如果没有两阶段提交，无论先写binlog还是先写redo log，在系统崩溃的情况下，都会出错。

# 3. 事务隔离

## 视图

读已提交和可重复读的实现方式是创建视图，然后通过MVCC控制事务能够访问的数据。在“可重复读”的隔离模式下，视图是在事务启动的时候创建的，整个事务存在期间都用这个视图。

在“读已提交”的隔离模式下，视图是在每个SQL语句开始执行的时候创建的。

![](./pic/3-MVCC.png)

# 6. 全局锁和表锁

## 全局锁

对整个数据库加锁，使用`flush tables with read lock`命令。

使用场景：做全库逻辑备份

对于支持事务的表，使用mysqldump -single-transaction 来做备份会更好，因为不会导致数据库在备份期间不可写。

## 表级锁

表级锁分两种，一种是表锁，一种是元数据锁(mete data lock, MDL)

- 表锁的语法是`lock table .. read/write`
- MDL不需要显示使用，在对表增删改查时，加MDL读锁，对表做结构变更操作时，加MDL写锁。

# 7.行锁

## 两阶段锁

行锁是在写SQL语句真正被执行的时候加的，在事务结束后才释放，因此尽量把加锁语句放到事务的后面。

## 死锁

对于死锁，有两种解决办法，一是超时回滚，二是主动死锁检测。死锁检测的计算量很大，而超时回滚不好控制超时时间的设置。

# 8. 事务

可重复读实现—视图。在事务启动时，创建一个视图，实际上就是一个事务数组，这个数组里面记录了此时活跃的所有事务id。

事务数组里面事务ID最小值记为低水位，当前系统里已经创建过的事务ID最大值称为高水位。

这个视图数组把所有的row trx_id分为了一下情况。

![](./pic/8-数据版本可见性.png)

对于当前事务来说，一个数据版本的row trx_id，有以下几种情况

- 落在绿色区域，表示这个版本是已提交或者当前事务自己生成的，可见。
- 落在红色部分，表示这个版本是由将来启动的事务生成的，肯定是不可见的。
- 落在黄色区域
  - 如果row trx_id在事务数组中，表示是未提交事务生成的，不可见。
  - 如果row trx_id不在事务数组中，表示是已经提交的事务生成的，可见。

对于读已提交，视图是在每条SQL执行的时候生成。

