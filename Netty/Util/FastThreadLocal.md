# Util 之 FastThreadLocal

之所以称之为 Fast，因为没有使用 JDK 的使用线性探测法的 Map(而是用数组搭配下标)，如果你使用的是Netty 线程池工厂创建的线程，搭配 Netty 的 ftl，性能非常好，如果你使用自定义的线程，搭配 ftl，性能也会比 JDK 的好，注意： ftl 没有 JDK 的内存泄露的风险(JDK的tl在线程池里，因为线程不被gc，导致tf的对象不被回收)。

但做到这些不是没有代价的，由于每一个 ftl 都是一个唯一的下标，而这个下标是每次创建一个 ftl 对象都是递增 2，当你的下标很大，你的线程中的 Map 相应的也要增大，可以想象，如果创建了海量的 ftl 对象，这个数组的浪费是非常客观的。很明显，这是一种空间换时间的做法。

通常，ftl 都是静态对象，所以不会有我们假设的那么多。如果使用不当，确实会浪费大量内存。

但这个风险带来的好处是明显的，在楼主的机器上测试，ftl 的读取性能是 JDK 的 5 倍左右，写入的速度也要快 20% 左右。

FastThreadLocal 人如其名，快且安全！

莫那一鲁道 [《Netty 高性能之道 FastThreadLocal 源码分析（快且安全）》](https://www.jianshu.com/p/3fc2fbac4bb7)

