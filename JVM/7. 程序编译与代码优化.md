## 7.1 早期（编译期）优化

有三种类型的编译器

- 前端编译器：把java文件转变为class文件，例如Javac
- JIT编译器：后端运行期编译器，把字节码转变成机器码，例如HotSpot VM的C1，C2编译器
- AOT编译器：静态提取编译器，直接把java文件编译成本地机器代码的过程。例如GNU Compiler for the Java(GCJ)

相当多新生的Java语法，都是靠编译器的语法糖来实现的，而不是依赖虚拟机的底层改进来支持。JIT在运行期的优化过程对于程序来说更重要，而前端编译器在编译期的优化过程对于程序编码来说关系更加密切。

### 7.1.1 Javac编译器

Javac的编译过程分为三个过程

![](./pic/7-1 Javac的编译过程.png)

1. 解析与填充符号表

   - 解析步骤包括词法分析和语法分析，词法分析将源代码的字符流转变为Token集合，语法分析根据Token序列构造抽象语法树。
   - 填充符号表，符号表是一组符号地址和符号信息构成的表格。符号表中的信息在不同编译阶段都要用到。

2. 注解处理器

   JDK1.5之后提供了对注解的支持，JDK1.6提供了一组注解处理器，可以看做是一组编译器的插件，在这些插件里面，可以读取，修改，添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析与填充符号表的过程，直到所有的注解处理器都没有再对语法树进行修改为止。

3. 语义分析与字节码生成

   语法分析后，得到了抽象语法树，它能够表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析主要是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。

   - **标注检查**，内容包括变量使用前是否已被声明，变量与赋值之间的数据类型是否能够匹配，还有常量折叠，例如

     ```java
     int a = 1 + 2
     // 折叠之后成为
     int a = 3
         
     ```

   - **数据及控制流分析**，对程序的上下文逻辑进行进一步验证，可以检查出程序局部变量在使用前是否赋值，方法每条路径是否都有返回值，是否所有的受检查异常都被正确处理了等问题。

   - **解语法糖**：解语法糖步骤会将java语法糖还原回简单的基础语法结构，因为虚拟机是不支持这些语法的。

   - **字节码生成**：这是Javac编译过程的最后一步，把前面各个步骤所生成的信息（语法树，符号表）转化成字节码写到磁盘中，编译器还做了少量的代码添加和转换工作。例如将类的初始化语句都放到<clint>方法中。

### 7.1.2 语法糖

- **泛型与类型擦除**，Java的泛型只存在于程序源码中，编译之后的字节码已经替换为原来的原生类型了，并且在相应地方加入了强制转型代码，所以泛型是java的语法糖，java泛型的实现方法称为类型擦除，是一种伪泛型。方法的Signature在Java层面只包括方法名称，参数顺序，以及参数类型。在字节码中的Signature还包括方法的返回值以及受查异常表。擦除法所谓的擦除，仅仅对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了类型信息，可以利用反射手段取得。
- **自动装箱、拆箱与遍历循环**
- **条件编译**，Java中，条件编译的实现，也是Java语言的一颗语法糖，根据布尔常量值的真假，编译器会把分支中不成立的代码块消除掉。
- 除此之外，还有其他语法糖，如内部类，枚举类，断言语句，对枚举类和字符串的switch支持，try语句中定义和关闭资源。

## 7.2 晚期（运行期）优化

### 7.2.1 HotSpot内的即时编译器

#### 7.2.1.1 解释器与编译器

- 并不是所有虚拟机都采用解释器和编译器共存架构（JRockit只有编译器，常用于服务端），但主流商用虚拟机都同时包含两者。

- 当程序需要迅速启动和执行时，解释器可以首先发挥作用。当运行环境中内存资源受限，使用解释执行可以节约内存，反之可以用编译器来提升效率。

- 解释器可以作为编译器激进优化的“逃生门”，当激进优化后，内部发生了改变，激进优化条件不再成立，可以以通过逆优化回退到解释执行。

- Client Compiler称为C1，Server Compiler 称为C2。

- 可用通过参数指定虚拟机的运行模式（client or server），也可以强制虚拟机运行在解释模式，或强制运行在编译模式（最新的HotSpot中已移除），此时将优先采用编译方式执行程序。

- 分层编译
  - 第0层，程序解释执行，解释器不开启性能监控功能
  - 第1层，也称为C1编译，将字节码编译为本地代码，进行简单，可靠的优化，必要时加入性能监控功能。
  - 第2层或以上，称为C2编译，也是将字节码编译为本地代码，但是会使用一些编译耗时长的优化，甚至根据性能监控信息进行一些不可靠的激进优化。

  分层编译实施后，C1和C2会同时工作，许多代码可能被多次编译，用C1获得更快的编译速度，用C2获得更好的编译质量。



