## 7.1 早期（编译期）优化

有三种类型的编译器

- 前端编译器：把java文件转变为class文件，例如Javac
- JIT编译器：后端运行期编译器，把字节码转变成机器码，例如HotSpot VM的C1，C2编译器
- AOT编译器：静态提取编译器，直接把java文件编译成本地机器代码的过程。例如GNU Compiler for the Java(GCJ)

相当多新生的Java语法，都是靠编译器的语法糖来实现的，而不是依赖虚拟机的底层改进来支持。JIT在运行期的优化过程对于程序来说更重要，而前端编译器在编译期的优化过程对于程序编码来说关系更加密切。

### 7.1.1 Javac编译器

Javac的编译过程分为三个过程

![](./pic/7-1 Javac的编译过程.png)

1. 解析与填充符号表

   - 解析步骤包括词法分析和语法分析，词法分析将源代码的字符流转变为Token集合，语法分析根据Token序列构造抽象语法树。
   - 填充符号表，符号表是一组符号地址和符号信息构成的表格。符号表中的信息在不同编译阶段都要用到。

2. 注解处理器

   JDK1.5之后提供了对注解的支持，JDK1.6提供了一组注解处理器，可以看做是一组编译器的插件，在这些插件里面，可以读取，修改，添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析与填充符号表的过程，直到所有的注解处理器都没有再对语法树进行修改为止。

3. 语义分析与字节码生成

   语法分析后，得到了抽象语法树，它能够表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析主要是对结构上正确的源程序进行上下文有关性质的审查，如进行类型审查。

   - **标注检查**，内容包括变量使用前是否已被声明，变量与赋值之间的数据类型是否能够匹配，还有常量折叠，例如

     ```java
     int a = 1 + 2
     // 折叠之后成为
     int a = 3
         
     ```

   - **数据及控制流分析**，对程序的上下文逻辑进行进一步验证，可以检查出程序局部变量在使用前是否赋值，方法每条路径是否都有返回值，是否所有的受检查异常都被正确处理了等问题。

   - **解语法糖**：解语法糖步骤会将java语法糖还原回简单的基础语法结构，因为虚拟机是不支持这些语法的。

   - **字节码生成**：这是Javac编译过程的最后一步，把前面各个步骤所生成的信息（语法树，符号表）转化成字节码写到磁盘中，编译器还做了少量的代码添加和转换工作。例如将类的初始化语句都放到<clint>方法中。

### 7.1.2 语法糖

- **泛型与类型擦除**，Java的泛型只存在于程序源码中，编译之后的字节码已经替换为原来的原生类型了，并且在相应地方加入了强制转型代码，所以泛型是java的语法糖，java泛型的实现方法称为类型擦除，是一种伪泛型。方法的Signature在Java层面只包括方法名称，参数顺序，以及参数类型。在字节码中的Signature还包括方法的返回值以及受查异常表。擦除法所谓的擦除，仅仅对方法的Code属性中的字节码进行擦除，实际上元数据中还是保留了类型信息，可以利用反射手段取得。
- **自动装箱、拆箱与遍历循环**
- **条件编译**，Java中，条件编译的实现，也是Java语言的一颗语法糖，根据布尔常量值的真假，编译器会把分支中不成立的代码块消除掉。
- 除此之外，还有其他语法糖，如内部类，枚举类，断言语句，对枚举类和字符串的switch支持，try语句中定义和关闭资源。

## 7.2 晚期（运行期）优化

### 7.2.1 HotSpot内的即时编译器

#### 7.2.1.1 解释器与编译器

- 并不是所有虚拟机都采用解释器和编译器共存架构（JRockit只有编译器，常用于服务端），但主流商用虚拟机都同时包含两者。

- 当程序需要迅速启动和执行时，解释器可以首先发挥作用。当运行环境中内存资源受限，使用解释执行可以节约内存，反之可以用编译器来提升效率。

- 解释器可以作为编译器激进优化的“逃生门”，当激进优化后，内部发生了改变，激进优化条件不再成立，可以以通过逆优化回退到解释执行。

- Client Compiler称为C1，Server Compiler 称为C2。

- 可用通过参数指定虚拟机的运行模式（client or server），也可以强制虚拟机运行在解释模式，或强制运行在编译模式（最新的HotSpot中已移除），此时将优先采用编译方式执行程序。

- 分层编译
  - 第0层，程序解释执行，解释器不开启性能监控功能
  - 第1层，也称为C1编译，将字节码编译为本地代码，进行简单，可靠的优化，必要时加入性能监控功能。
  - 第2层或以上，称为C2编译，也是将字节码编译为本地代码，但是会使用一些编译耗时长的优化，甚至根据性能监控信息进行一些不可靠的激进优化。

  分层编译实施后，C1和C2会同时工作，许多代码可能被多次编译，用C1获得更快的编译速度，用C2获得更好的编译质量。

#### 7.2.1.2 编译对象与触发条件

有两类会在运行过程中被JIT认为是“热点代码”：

- 被多次调用的方法
- 被多次执行的循环体（连同整个方法一起编译，这种编译方式因为发生在方法执行过程之中，因此称为栈上替换。）

判断一段代码是不是热点代码，称为热点探测，目前有两种方式：

- 基于采样的热点探测：周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这个方法就是热点方法。好处是实现简单，高效。缺点是很难精确确认一个方法的热度，容易受到线程阻塞或别的外界因素的影响。
- 基于计数器的热点探测：为每个方法甚至是代码块建立计数器，统计方法的执行次数，超过阈值时就认为是热点代码。实现起来麻烦，但是统计结果更加精确，严谨。

HotSpot虚拟机使用的是第二种，基于计数器的热点探测方法。

- 方法调用计数器，用于统计方法调用次数，在Client模式下的阈值为1500，在Server模式下的阈值为10000次。

  流程如下：

  ![](./pic/7-2 方法调用计数器触发及时编译.png)

计数器热度衰减：超过一定时间，如果方法的调用次数仍不能触发编译，计数器数值将会减少一半，如果没有这个机制，随着虚拟机一直运行，所有方法的调用次数最终都将到达编译阈值。

- 回边计数器：用来统计一个方法中，循环体代码被执行的次数。在字节码中遇到控制流向后跳转的指令称为回边。回边计数器的阈值由方法调用计数器的阈值算出。有具体的公式。回边计数器没有热度衰减。当回边计数器溢出时，也会将方法计数器调整到溢出状态，下次再进入该方法就会执行标准编译过程。

#### 7.2.1.3 编译过程

- 默认情况下，当编译请求发起之后，在编译完成之前，代码还是按照解释执行的方法运行，而编译动作在后台的编译线程中执行。当禁用后台编译后，一旦到达JIT编译条件，执行线程提交编译请求后将会一直等待，知道编译过程完成后再开始执行编译后的代码。

### 7.2.2 编译优化过程

以编译方式执行本地代码比解释方式更快，原因有二

- 虚拟机解释执行字节码会额外消耗时间。
- 虚拟机团队几乎把对代码的所有优化措施都集中在即时编译器中。因此，即时编译器产生的本地代码，比解释执行产生的本地代码更加优秀。

#### 7.2.2.1 优化技术

- 公共子表达式消除：重用之前计算过的表达式，当表达式中的值没有变化时。

  ```java
  int d = (c * b) * 12 + a + (a + b * c) 
  // 优化后
  int d = E * 12 + a + (a + E) 
  ```

- 数组边界检查消除：在编译器，对数据流分析来确定数组的长度，就可以在访问数组时，省去边界判断的工作。

- 方法内联：将调用方法的代码插入调用处，除去了方法调用的成本，为其他优化建立良好基础。由于Java中的实例方法默认是虚方法，也就是在编译的时候不确定会具体是哪一种方法的实现，因此为方法内联带来困难，对此做出的方案是：
  - 通过CHA技术，分析类型继承关系
  - 编译器在内联时，如果是非虚方法，直接内联
  - 遇到虚方法，会向CHA查询当下程序是否有多个目标版本可供选择，如果查到只有一个版本，则可以内联，这种内联属于激进优化，需要预留逃生门。当虚拟机此后加载了导致继承关系变化的新类，那就需要抛弃已编译的代码，回退到解释执行状态。
  - 使用内联缓存，在这个新加入的类中的该方法被真正调用之前，还可以使用之前编译好的代码。
- 逃逸分析：分析对象动态作用域，为其他优化提供依据的分析技术。
  - 逃逸：一个对象在方法中被定以后，它可能被外部方法引用，称为方法逃逸。甚至被别的线程访问到，这称之为线程逃逸。如果能证明这个变量不会逃逸，则可以进行一些高效的优化。例如
    - 栈上分配：将变量分配在栈上，对象使用的内存会随着栈帧出栈而销毁。
    - 同步消除：如果确定一个变量不会逃出线程，则对这个变量实施的同步措施（synchronized关键字）可以消除掉。
    - 标量替换：标量是指一个数据不能被分解成更小的数据了。用标量的集合来代替一个对象，也就是把一个对象拆分成许多标量，而不用去创建这个对象，而标量可以分配到栈上，就可以减少GC压力。

### 7.2.3 Java与C++编译器对比

- 劣势：
  - 即时编译器运行占用的是用户程序的运行时间，有很大的时间压力。
  - Java因为是动态的类型安全语言，意味着虚拟要频繁动态检查，例如检查空指针，数组元素越界访问检查，类型转换时继承检查，会消耗不少时间。
  - 使用虚方法的频率远远大于C++，因此许多优化更难以实施。
  - Java是可以动态扩展的语言，运行时可以加载新类，导致很多全局优化都难以进行，虚拟机需要时刻注意类型的变化而在运行时撤销或者重新进行一些优化。
  - Java的内存管理是托管给虚拟机，依赖于GC。而C++的内存管理靠用户程序，运行时效率会更高。
- 优势：
  - 开发效率极大提高
  - Java编译器可以利用动态性，以运行期性能监控为基础，进行一些优化。