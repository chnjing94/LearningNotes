## 6.1 运行时栈帧结构

栈帧里面包括局部变量表，操作栈，动态链接，返回地址

### 6.1.1 局部变量表

- 局部变量表以slot为最小单位，大小不确定，但是要求能存下一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据。
- 对于64位数据，虚拟机会分配两个slot。
- 在执行方法时，如果执行的是实例方法，那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用。
- 为了节省空间，局部变量表是可以被重用的，所以当一个大对象使用完毕，在没有对局部变量写入新变量之前，变量表里还存在这个大对象的引用，当有新的变量写入的时候，之前那个大对象的引用才会被覆盖掉。因此有人提出对于不再使用的变量，手动将其设置为null值。但是，代码在经过JIT编译后，赋值null的语句被消除掉了，因此设置为null的语句是无效的。

### 6.1.2 操作数栈

操作数栈，也称为操作栈，是一个后入先出栈。元素可以使任意的Java数据类型。32位数据占栈容量为1，66位数据类型所占栈容量为2。举个例子，整数加法字节码指令iadd在运行时将最接近栈顶的两个int型相加，将结果出栈。

### 6.1.3 动态链接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用的目的，是为了支持方法调用过程中的动态链接。Class文件常量池中的符号引用，在运行过程中转化为直接引用，这部分称为动态链接。符号引用在类加载阶段或者第一次使用的时候转化为直接引用，称为静态解析。

### 6.1.4 方法返回地址

方法执行后，有两种方式退出这个方法，第一种，遇到任意一个返回的字节码，这个时候可能会有返回值传递给方法调用者，这种称为正常完成出口。另一种退出方式是，在执行过程中遇到了异常，并且没有在方法体中得到处理，例如虚拟机内部产生的异常，或者字节码athrow产生的异常。这种退出叫做异常完成出口。

方法正常退出时，调用者的PC计数器的值可以作为返回地址。异常退出时，返回地址要通过异常处理器表来确定。

## 6.2 方法调用

方法调用不是方法执行，这个阶段的目的只是确定被调用方法的版本（即调用哪一个方法）。Class文件的编译过程不包括传统编译中的连接步骤，所以方法调用在Class文件中都只是符号引用，而不是方法在实际运行时内存中的入口地址（也就是直接引用）。

### 6.2.1 解析

在类加载的解析阶段，会将其中一部分符号引用转化为直接引用，但是前提是，方法在程序真正运行之前就有一个可以确定的调用版本，且在运行期间不可变。这类方法的调用就称为解析。

在Java中符合上述描述的方法有两类，静态方法和私有方法，它们无法被继承和重写。Java提供了5条方法调用字节码指令。分别如下。

1. Invokestatic:调用静态方法
2. Invokespecial: 调用实例构造器方法，私有方法和父类方法
3. Invokevirtual：调用所有的虚方法
4. Invokeinterface: 调用接口方法，在运行时再确定一个实现此接口的对象
5. Invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

只要能被Invokestatic，Invokespecial指令调用的方法，都能在解析阶段确定它的唯一版本。例如，静态方法，私有方法，实例构造器，父类方法四种。这些方法可以被称为非虚方法，其他方法称为虚方法（除去final方法）。Java中的非虚方法还有一种，就是被final修饰的方法，虽然final方法是用invokevirtual来调用，但是由于它无法被覆盖，也没有其他版本，因此在Java语言规范中，说明了final方法是一种非虚方法。

### 6.2.2 分派（dispatch）

1. 静态分派，所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，静态分派的典型应用就是方法重载。编译器能够在多个可重载版本中，选择一个最合适的版本。
2. 动态分派，跟重写有着密切关系。在调用一个对象的虚方法时，对应指令是invokevirtual,invokevirtual指令在运行时的解析过程为
   1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，计作C
   2. 如果在C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过就返回这个方法的直接引用，查找结束。
   3. 否则，按照继承关系从下往上对C的父类进行第二步的搜索和验证过程
   4. 如果始终没找到，就抛出AbstractMethodError异常
3. 动态分派实现，在类的方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找以提高性能。具有相同签名的方法，在子类，父类的虚方法表中都具有一样的索引序号，当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。
4. 方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机就会把方法表初始化完毕。

### 6.2.3 动态类型语言支持

1. invoke包：在以前单纯靠符号引用来确定调用的目标方法这种方式以外，提供了一种新的动态确定目标方法的机制，称为MethodHandle。可以将它作为参数传递到函数中，相当于传一个函数作为参数。和反射的区别：
   - 反射是在模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的调用，例如MethodHandle.lookup中的3个方法-findStatic()、findVirtual()、findSpecial()。对应invokestatic, invokevirtual, invokespecial这几条字节码指令的执行权限校验行为。
   - 反射是重量级的，MethodHandle是轻量级的。
   - MethodHandle是对字节码的方法指令调用的模拟，所以虚拟机在这方面做的优化，在MethodHandle上也可以有。
   - MethodHandle可以服务于所有虚拟机上的语言。反射是针对Java的。
2. invokedynamic指令：和MethodHandle机制作用是一样的，为了把如何查找目标方法的决定权从虚拟机转嫁给用户代码中，让用户有更高自由度。
   - 每一处含有invokedynamic指令的位置，都称作动态调用点
   - 这条指令的第一个参数不再是符号引用，而是CONSTANT_InvokeDynamic_info常量，这个常量包含三个变量，引导方法，方法类型和名称。根据CONSTANT_InvokeDynamic_info常量，虚拟机可以找到并执行引导方法，从而获得一个CallSite对象，这个对象代表真正要执行的目标方法,最终调用要执行的目标方法。
3. 掌控方法分派规则：利用MethodHandle，可以让子类调用祖父类的方法。

## 6.3 基于栈的字节码解释执行引擎

### 6.3.1 解释执行

![](./pic/6-1 编译过程.png)

编译过程如上图，中间那条分支是解释执行，下面那条分支是传统的程序代码到目标机器代码的生成过程。C/C++将词法分析，语法分析以至于后面的优化器和目标代码生成器形成一个完整意义的编译器去实现。Java将一部分步骤，词法分析，语法分析，抽象语法树，生成字节码指令流的过程实现为一个半独立的编译器。而JS执行器把这些步骤和执行步骤全部封装在一个黑匣子中。

### 6.3.2 基于栈的指令集和基于寄存器的指令集

基于栈的指令集

- 好处：可移植，不依赖于硬件，而基于寄存器的指令集会受到硬件的约束。代码相对紧凑（字节码中每个字节对应一条指令，而多地址指令集还需存放参数），编译器更加简单（不需要考虑空间分配问题）

  缺点：慢！出栈入栈产生了相当数量的指令，栈实现在内存中，频繁访问内存增大了性能开销。