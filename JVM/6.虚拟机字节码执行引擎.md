## 4.1 运行时栈帧结构

栈帧里面包括局部变量表，操作栈，动态链接，返回地址

### 4.1.1 局部变量表

- 局部变量表以slot为最小单位，大小不确定，但是要求能存下一个boolean、byte、char、short、int、float、reference或returnAddress类型的数据。
- 对于64位数据，虚拟机会分配两个slot。
- 在执行方法时，如果执行的是实例方法，那么局部变量表的第0位索引的Slot默认是用于传递方法所属对象实例的引用。
- 为了节省空间，局部变量表是可以被重用的，所以当一个大对象使用完毕，在没有对局部变量写入新变量之前，变量表里还存在这个大对象的引用，当有新的变量写入的时候，之前那个大对象的引用才会被覆盖掉。因此有人提出对于不再使用的变量，手动将其设置为null值。但是，代码在经过JIT编译后，赋值null的语句被消除掉了，因此设置为null的语句是无效的。

### 4.1.2 操作数栈

操作数栈，也称为操作栈，是一个后入先出栈。元素可以使任意的Java数据类型。32位数据占栈容量为1，64位数据类型所占栈容量为2。举个例子，整数加法字节码指令iadd在运行时将最接近栈顶的两个int型相加，将结果出栈。

### 4.1.3 动态链接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用的目的，是为了支持方法调用过程中的动态链接。Class文件常量池中的符号引用，在运行过程中转化为直接引用，这部分称为动态链接。符号引用在类加载阶段或者第一次使用的时候转化为直接引用，称为静态解析。

### 4.1.4 方法返回地址

方法执行后，有两种方式退出这个方法，第一种，遇到任意一个返回的字节码，这个时候可能会有返回值传递给方法调用者，这种称为正常完成出口。另一种退出方式是，在执行过程中遇到了异常，并且没有在方法体中得到处理，例如虚拟机内部产生的异常，或者字节码athrow产生的异常。这种退出叫做异常完成出口。

方法正常退出时，调用者的PC计数器的值可以作为返回地址。异常退出时，返回地址要通过异常处理器表来确定。

## 4.2 方法调用

方法调用不是方法执行，这个阶段的目的只是确定被调用方法的版本（即调用哪一个方法）。Class文件的编译过程不包括传统编译中的连接步骤，所以方法调用在Class文件中都只是符号引用，而不是方法在实际运行时内存中的入口地址（也就是直接引用）。

### 4.2.1 解析

在类加载的解析阶段，会将其中一部分符号引用转化为直接引用，但是前提是，方法在程序真正运行之前就有一个可以确定的调用版本，且在运行期间不可变。这类方法的调用就称为解析。

在Java中符合上述描述的方法有两类，静态方法和私有方法，它们无法被继承和重写。Java提供了5条方法调用字节码指令。分别如下。

1. Invokestatic:调用静态方法
2. Invokespecial: 调用实例构造器方法，私有方法和父类方法
3. Invokevirtual：调用所有的虚方法
4. Invokeinterface: 调用接口方法，在运行时再确定一个实现此接口的对象
5. Invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

只要能被Invokestatic，Invokespecial指令调用的方法，都能在解析阶段确定它的唯一版本。例如，静态方法，私有方法，实例构造器，父类方法四种。这些方法可以被称为非虚方法，其他方法称为虚方法（除去final方法）。Java中的非虚方法还有一种，就是被final修饰的方法，虽然final方法是用invokevirtual来调用，但是由于它无法被覆盖，也没有其他版本，因此在Java语言规范中，说明了final方法是一种非虚方法。

### 4.2.2 分派（dispatch）

1. 静态分派，所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，静态分派的典型应用就是方法重载。编译器能够在多个可重载版本中，选择一个最合适的版本。
2. 动态分派，跟重写有着密切关系。在调用一个对象的虚方法时，对应指令是invokevirtual,invokevirtual指令在运行时的解析过程为
   1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，计作C
   2. 如果在C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过就返回这个方法的直接引用，查找结束。
   3. 否则，按照继承关系从下往上对C的父类进行第二步的搜索和验证过程
   4. 如果始终没找到，就抛出AbstractMethodError异常