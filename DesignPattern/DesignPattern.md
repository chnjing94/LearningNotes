## 创建型

### 工厂模式

工厂是负责生产对象的，使用工厂模式的初衷是为了将对象的使用和创建这两个步骤解耦。

#### 简单工厂

也叫静态工厂方法，根据给定的条件，直接new一个目标对象，简单工厂就是一个Java Class。

#### 工厂方法

由于生成目标对象的过程不再是简单地new一个对象，而是较为复杂的过程，那么生成对象的code应该独立出来放到单独的类中。因此之前的一个简单工厂对象，被拆分成独立的多个工厂对象。

首先要定义一个工厂接口，该接口只有一个方法，该方法生成一个对象。每种工厂实现类都要继承这个接口。在调用过程中，根据给定的条件，先拿到对应的工厂对象，再调用工厂对象去生成对应的对象。

#### 抽象工厂

当一个工厂对象不只生成一种对象的时候，这个时候就应该使用抽象工厂模式。

首先定义一个工厂接口，该接口有多个方法，分别生成多种对象。

抽象工厂较为少用，因为它的出现代表着很高的业务复杂度。

## 行为型

### 模板方法模式

模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。

#### 实现

在模板模式经典的实现中，模板方法定义为 final，可以避免被子类重写。需要子类重写的方法定义为 abstract，可以强迫子类去实现。不过，在实际项目开发中，模板模式的实现比较灵活，以上两点都不是必须的。

#### 作用

模板模式有两大作用：复用和扩展。其中，复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。

#### 模板模式 VS 回调

从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式。

从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系。

前面我们也讲到，组合优于继承。实际上，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点。

- 像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力。
- 回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类。
- 如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可。

