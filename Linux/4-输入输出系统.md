# 4. 输入输出系统

## 4.1 概述

计算机的输入输出设备有键盘、鼠标、显示器、网卡、打印机、CD等等，操作系统需要一种统一的方法来管理各种各样的设备。下图就是操作系统提供的方案，从下往上讲。

![](./pic/4-输入输出概述.jpg)

### 4.1.1 用设备控制器屏蔽设备差异

每种设备都有自己的设备控制器，例如磁盘控制器，USB控制器，显示器控制器。控制器是由设备自带的。

设备控制器就像一个小电脑一样，有自己的芯片可以执行逻辑，有自己的寄存器，CPU通过写这些寄存器，对控制器下指令。通过读这些寄存器，查看控制器对设备的操作状态。

输入输出设备大致可以分为两类：

- 块设备：将信息存储在固定大小的块中，每个块都有自己的地址，例如硬盘。
- 字符设备，发送和接收的都是字节流，不用考虑任何块结构，无法寻址，例如鼠标。

对于块设备的读写，因为数据量比较大，控制器会有缓冲区。需要攒够一定的数据才读出或写入。

CPU如何与控制器的寄存器以及数据缓冲区通信？

- 给每个控制寄存器分配一个I/O端口，通过特殊得汇编指令操作这些寄存器。
- 通过内存映射，分配一段内存空间给数据缓冲区，就可以向读写内存一样读写数据缓冲区，内存空间的ioremap就是做这个的。

CPU给设备控制器下达命令后就可以去干自己的事了，当设备控制器做完之后，会利用中断处理器发送一个中断，通知CPU任务已经完成，CPU需要停下当前的任务来处理中断。

由中断处理器发出的中断叫做硬件中断，通过系统调用产生的叫做软中断。

对于磁盘来说，有一个DMA芯片来协助读取数据，CPU发送读请求给DMA，告诉它去哪里取，取多少数据。DMA发送指令给磁盘控制器，去磁盘上读出数据后放到指定内存区域，然后发送中断告诉CPU数据准备好了。

### 4.1.2 用驱动程序屏蔽设备控制器差异

由于各种设备控制器的寄存器，缓冲区，指令都不同，对于操作系统来说，还需要一种途径来屏蔽这个差异。设备驱动程序就是起到这个作用的。

设备控制器不是操作系统的一部分，设备驱动程序属于操作系统，内核可以像调用本地代码一样调用驱动程序的代码，驱动程序的代码需要发出特殊的面向设备控制器的指令，才能操作设备控制器。

驱动程序有统一的接口供操作系统调用，这样操作系统就能以统一方式，无视设备的区别，调用设备驱动程序。

中断处理的逻辑也是写在设备驱动程序里的。当一个设备驱动程序初始化时，要先注册一个该设备的中断处理函数，中断返回的时候，是切换进程的时机，这个时候就可以找到设备驱动程序注册的中断处理函数Handler，然后执行它进行中断处理。

对于块设备来说，在驱动程序之上，文件系统之下，有一层通用块设备层，将与块设备相关的通用逻辑放在这一层，维护与设备无关的块的大小，然后通用块层下面对接各种各样的驱动程序。

### 4.1.3 用文件系统接口屏蔽驱动程序的差异

从硬件设备到设备控制器，到驱动程序，到通用块层，到文件系统，层层屏蔽不同的设备的差别，最终到这里涉及对用户使用接口，也要统一。

用户操作设备都是基于文件系统的接口，也有统一的标准。

首先是有统一的设备名称，所有的设备都在/dev/文件下创建一个特殊的设备文件。这个设备文件也有inode，但是不关联到硬盘或任何其他存储介质上的数据，而是建立了与某个设备驱动程序的连接。

在/dev下执行ls -l会有如下结果：

```c
# ls -l
crw------- 1 root root      5,   1 Dec 14 19:53 console
crw-r----- 1 root kmem      1,   1 Dec 14 19:53 mem
crw-rw-rw- 1 root root      1,   3 Dec 14 19:53 null
crw-r----- 1 root kmem      1,   4 Dec 14 19:53 port
crw-rw-rw- 1 root root      1,   8 Dec 14 19:53 random
crw--w---- 1 root tty       4,   0 Dec 14 19:53 tty0
crw--w---- 1 root tty       4,   1 Dec 14 19:53 tty1
crw-rw-rw- 1 root root      1,   9 Dec 14 19:53 urandom
brw-rw---- 1 root disk    253,   0 Dec 31 19:18 vda
brw-rw---- 1 root disk    253,   1 Dec 31 19:19 vda1
brw-rw---- 1 root disk    253,  16 Dec 14 19:53 vdb
brw-rw---- 1 root disk    253,  32 Jan  2 11:24 vdc
crw-rw-rw- 1 root root      1,   5 Dec 14 19:53 zero
```

第一位是c表示这是一个字符设备，b代表这是一个块设备。后面两个数字代表主设备号，和次设备号。主设备号定位设备驱动程序，次设备号表示使用这个驱动程序的设备。

当Linux操作系统新添加了一个设备，就会加载相应的驱动程序，相当于加载一个内核模块。通过insmod安装内核模块，内核模块的后缀一般是ko。

有了驱动之后，就可以用mknod在/dev文加下创建设备文件。以上是手动加载一个设备的过程。

自动管理新连接设备的流程如下，在/sys下有一个sysfs文件系统，这个文件系统是当前系统上实际设备数的真实反映。

- /sys/devices是内核对系统中所有设备的分层次表示
- /sys/dev下一个char文件夹，一个block文件夹，分别维护一个按字符设备和块设备的主次号码链接到真实设备(/sys/devices下)的符号链接文件。
- /sys/block是所有的块设备
- /sys/module是所有模块的信息。

有一个守护进程udev，当新设备插入是，内核会检测到这个设备，并创建一个内核对象kobject。向用户空间发送一个热插拔消息。udevd会监听这些消息，在/dev中创建对应的文件。

有了文件系统接口之后，就能像读写文件一样操作设备了，除了read, write还有ioctl接口用于特殊的控制。

## 4.2 字符设备

这里通过字符设备的驱动来了解驱动程序的架构。以鼠标和打印机为例。

### 4.2.1 字符设备驱动程序

罗技鼠标的驱动程序logibm.c

```c
/*
 * Logitech Bus Mouse Driver for Linux
 */
module_init(logibm_init);
module_exit(logibm_exit);
```

惠普打印机的驱动程序lp.c

```c
/*
 * Generic parallel printer driver
 */
module_init(lp_init_module);
module_exit(lp_cleanup_module);
```

作为一个驱动程序，也是一个内核模块，应该具有以下部分：

- 头文件部分，一般内核模块都需要引用以下头文件：

  ```c
  #include <linux/module.h>
  #include <linux/init.h>
  ```

- 定义处理内核模块主要逻辑的函数，例如打开、关闭、读取、写入以及中断处理函数等。

- 定义一个file_operations，这样就可以通过文件系统的接口对设备进行访问。

- 定义整个模块的初始化和退出函数，用于加载和卸载这个ko的时候使用。

- 调用module_init和module_exit，分别指向初始化和退出函数。

- 声明一下lisense。

### 4.2.2 打开字符设备

第一次打开字符设备的步骤如下：

1. 调用module_init初始化函数，来加载这个设备驱动程序。最重要的事是注册这个字符设备，为其注册主次设备号和名称，然后分配一个struct cdev，cdev的ops成员变量指向这个模块声明的file_operations。将cdev添加到cdev_map结构中，用来统一管理所有字符设备。
2. 调用mknod在/dev下创建一个设备文件。这个文件是个特殊文件，对应的inode也是特殊的。
3. 调用open打开这个特殊的inode，找到其cdev，将里面定义的file_operations交付给struct file里面的file_operations，这样以后操作文件描述符，就是直接操作设备了。
4. 最后调用设备驱动程序的file_operations的open函数，真正打开设备。

### 4.2.3 写入字符设备

写入字符设备，就是用文件系统标准接口write，参数为文件描述符。找到fd对应的struct file，调用其file_operations的write函数，最终就是调用驱动程序的file_operations的write。

### 4.2.4 使用IOCTL控制设备

ioctl是一个系统调用，参数为fd和命令cmd，cmd是驱动程序约定好的。对于设备驱动文件，会调用vfs_ioctl，就会调用到设备驱动程序的file_operations的unlocked_ioctl函数，去执行相关命令。