###   ==、equals与hashcode

- ==比较内存地址
- equals是Object类的方法，默认实现用==比较两个对象
- hashCode：内存地址=>int
- 重写equals必须重写hashCode，否则无法正常在基于hash值的集合类中运行。
- equals为true，hashCode一定要相等。反之不一定。



### 值传递和引用传递

- Java只有值传递，无论基础类型还是引用类型
- 从函数调用栈的角度去理解
- 基础类型的值直接分配在栈上

### Final关键字

- final变量初始化时机
  - 定义时
  - final成员变量可在初始化块，不可在static块。static final变量可在static块中。
  - final成员变量可在构造器中初始化，static final变量不行。
- 调用final方法=>内联
- 匿名内部类只能用外部类中final修饰的变量， 因为匿名内部类用到外部类的变量时机不确定，如果不用final变量，可能导致结果不确定。                                                                                                                                                                                                

### volatile关键字

- 可见性，有序性(插入内存屏障禁止内存重排序，保证happens-before原则)，不保证原子性。
- 1.5之前只保障可见性，1.5增强了语义，添加了happens-before原则，保障了有序性。
- 写volatile变量时，JVM执行Write-Barrier指令，将当前处理器缓存中的数据写回系统内存，并使其他CPU核里引用了该地址的数据成为脏数据。
- 读volatile变量时，JVM执行Read-Barrier指令，如果该数据已经变脏，则从主内存重新读取数据。
- StoreStore，StoreLoad，LoadStore，LoadLoad

### synchronized关键字

- synchronized方法实现原理：JVM使用`ACC_SYNCHRONIZED`标记符标记方法，来实现同步。
- synchronized代码块：JVM采用`monitorenter`、`monitorexit`两个指令来实现同步。

- `ACC_SYNCHRONIZED`、`monitorenter`、`monitorexit`基于Monitor实现。Monitor提供如`enter`、`exit`、`wait`、`notify`、`notifyAll`等方法。
- 原子性：`monitorenter`加锁
- 可见性：对一个变量解锁之前，必须先把此变量同步回主存中。
- 有序性：虽然`synchronized`是无法禁止指令重排和处理器优化的。由于`synchronized`修饰的代码，同一时间只能被同一线程访问。那么也就是单线程执行的。所以，可以保证其有序性。

### 泛型

- 数组是具象化的，会保存数组内元素的类型信息，而泛型在运行时会被擦除。

- 泛型在运行时被擦除，擦除之后变为泛型的原始类型，一般而言对应泛型的定义上界。在运行时需要的地方做类型转换。

- 泛型擦除不代表泛型信息完全丢弃，只有局部代码块中的泛型被擦除。而接口、类、方法、成员变量上定义的泛型信息会被保留，这部分信息可通过反射获取。

- 通过反射能够获类中定义的泛型信息，不能在运行时，获取某个实例的具体泛型信息（因为被擦除了）。

- 类型检查是针对引用，而不是引用实际指向的对象。

  ```java
  List<Integer> list1 = new ArrayList();
  list1.add(1);
  List1.add("a"); //报错
  
  List list2 = new ArrayList<Integer>();
  list1.add(1);
  List1.add("a"); //不报错
  Integer i = list2.get(0); //报错
  ```

- 泛型不能是基本数据类型

### Java版本新特性

- 8：Lambda；函数式接口(有且仅有一个抽象方法的接口)；接口支持默认方法和静态方法；方法引用；Optional类；Stream类；日期新特性；调用JavaScript；
- 9：JShell；不可变集合工厂方法；接口支持私有方法；模块化；Reactive Stream API；

### 序列化

- serialVersionUID作用：在反序列化时，判断序列化对象是否和目标类匹配。

### 浮点数

- 定点数
- a = m × 2^e

### String

#### 长度限制

- Java虚拟机规范规定字符串常量池中的值长度表示为16位无符号，最大长度2^16-1，65535，不超过65535，因此长度为65534。

- javac中检查字符串常量代码如下

  ```java
  private void checkStringConstant(DiagnosticPosition var1, Object var2) {
      if (this.nerrs == 0 && var2 != null && var2 instanceof String && ((String)var2).length() >= 65535) {
          this.log.error(var1, "limit.string", new Object[0]);
          ++this.nerrs;
      }
  }
  ```

- 编译期字符串最长65534

- 运行期最长为Integer.MAX_VALUE，最长的字符串按unicode编码，需要内存约等于4G。

#### substring

```java
String x = "abcdef";
x = x.substring(1,3);
System.out.println(x);	
```

**Java6:**

![](./pic/string-substring-jdk6-650x389.jpeg)

```java
public String substring(int beginIndex, int endIndex) {
    //check boundary
    return  new String(offset + beginIndex, endIndex - beginIndex, value);
}
```

缺陷：字符数组被多处引用，有内存泄漏风险。



**Java7:**

![](./pic/string-substring-jdk71-650x389.jpeg)

```java
public String(char value[], int offset, int count) {
    //check boundary
    this.value = Arrays.copyOfRange(value, offset, offset + count);
}

public String substring(int beginIndex, int endIndex) {
    //check boundary
    int subLen = endIndex - beginIndex;
    return new String(value, beginIndex, subLen);
}
```

使用`new String`创建了一个新字符串，避免对老字符串的引用。从而解决了内存泄露问题。

#### StringBuffer和StringBuilder

- 封装了一个非fianl 的char[] value;
- `StringBuffer`线程安全，使用synchronized方法保证线程安全。而`StringBuilder`则不是线程安全的。

#### 字符串拼接

速度：`StringBuilder`<`StringBuffer`<`concat`<`+`<`StringUtils.join`

#### switch对String的支持

- switch实际只能使用整形，char会转化为ascii码，String对象会转化为哈希值。

### 常量池

#### 字符串常量池

- 字符串常量池存放在方法区，jdk7之前，方法区由永久代实现，位于JVM内部。
- jdk7中，字符串常量池存放到堆中。
- jdk8使用元空间替代永久代来实现方法区，字符串常量池从堆中移到元空间中，元空间存在于虚拟机之外，使用本地内存。

#### Class常量池

- 记录在.class文件中

- 作为媒介场所，用于存放编译器生成的字面量(Literal)和符号引用(Symbolic References)。

- **字面量(Literal)**：由字母、数字等构成的字符串或者数值。字面量只可以右值出现，

  ```
  int a = 123;
  String s = "hollis";
  ```

- **符号引用(Symbolic References)**：类和接口的全限定名；字段的名称和描述符；方法的名称和描述符。符号引用在类创建时或运行时解析、翻译到具体的内存地址之中。

  ```
  com/hollis/HelloWorld、main、([Ljava/lang/String;)V
  ```

- **作用**： 在JVM真的运行时，需要把常量池中的常量（字面量和符号引用）加载到内存中。

#### 运行时常量池

- 运行时常量池（ Runtime Constant Pool）是每一个类或接口的常量池（ Constant_Pool）的运行时表示形式。
- 分配在 Java 虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。
- 运行时常量池中的内容包含：Class常量池和字符串常量池中的常量

